{% extends "base.html" %}

{% block content %}
<head>
<style>
    #video-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 20px auto;
    width: 80%;
    max-width: 800px;
    border: 2px solid #ddd;
    border-radius: 8px;
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
    background-color: #f9f9f9;
    padding: 20px;
}

video {
    width: 100%;
    height: auto;
    background-color: black;
    border-radius: 8px;
}

#status-message {
    text-align: center;
    font-size: 1.2em;
    color: #333;
    margin-top: 10px;
}

#torrent-graph-container {
    margin-top: 20px;
    width: 80%;
    max-width: 800px;
}

#profile-container {
    margin-top: 30px;
    width: 80%;
    max-width: 800px;
    text-align: center;
}

h1, h2, h3 {
    color: #333;
}

</style>
</head>


<div id="video-container">
    <video id="player" autoplay playsinline controls muted style="width: 100%; height: 60vh; background-color: black;">
        <p class="vjs-no-js">
            To view this video, please enable JavaScript, and consider upgrading to a web browser that
            <a href="https://videojs.com/html5-video-support/" target="_blank">supports HTML5 video</a>.
        </p>
    </video>
    <p id="status-message">Loading stream...</p>
</div>

<!-- Torrent Graph to visualize download and connection stats -->
<div id="torrent-graph-container" style="width: 100%; height: 250px; margin-top: 20px;">
    <canvas id="torrent-graph" width="100%" height="100%" style="background-color: #f9f9f9;"></canvas>
</div>

<!-- Profile container and other page elements -->
<div id="profile-container">
    <h1>User Profile</h1>
    <h2 id="profile-name">Ethereum Address: <span id="eth-address">{{ eth_address }}</span></h2>

    <!-- Spider chart for user skills -->
    <h3>User Skills Overview</h3>
    <canvas id="skillChart"></canvas>

    <!-- List of Published Papers -->
    <h3>Published Papers</h3>
    <ul id="published-papers-list"></ul>
    <p id="no-papers-message" style="display:none;">No papers have been published yet.</p>

    <!-- Overall User Rating -->
    <h3>Overall User Rating: <span id="user-rating">N/A</span></h3>
    <p id="no-rating-message" style="display:none;">This user has not been rated yet.</p>

    <!-- Tipping Section (hidden if it's the user's own profile) -->
    <div id="tip-section" style="display:none;">
        <h3>Tip the Author</h3>
        <form id="tip-form">
            <input type="number" id="tip-amount" placeholder="Enter amount in ETH" min="0.01" step="0.01" required>
            <button type="submit">Tip</button>
        </form>
    </div>
</div>

<div id="custom-html-content"></div>


{% endblock %}

{% block scripts %}
<script src="https://webtorrent.io/bundle.js"></script>
<script src="https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@1.3.0/dist/web3.min.js"></script>

<script>
    const ethAddress = "{{ eth_address }}";  // Get the Ethereum address from Flask
    const client = new WebTorrent();  // Initialize WebTorrent
    const videoElement = document.getElementById("player");
    let videoQueue = [];  // Queue to manage the downloaded videos in the correct order
    const processedMagnetUrls = new Set();  // To prevent duplicate processing
    let currentVideoIndex = 0;
    let isPlaying = false;

    // Add console logs for video element events
    videoElement.addEventListener('canplay', () => {
        console.log('Video can start playing, but may have to buffer.');
    });

    videoElement.addEventListener('canplaythrough', () => {
        console.log('Video can play through without stopping for buffering.');
    });

    videoElement.addEventListener('play', () => {
        console.log('Video playback started.');
    });

    videoElement.addEventListener('pause', () => {
        console.log('Video playback paused.');
    });

    videoElement.addEventListener('ended', () => {
        console.log('Video playback ended.');
        handleVideoEnd(); // Trigger next video
    });

    videoElement.addEventListener('waiting', () => {
        console.log('Video is waiting for more data.');
    });

    videoElement.addEventListener('error', (error) => {
        console.error('Error occurred in video element:', error);
    });

    document.addEventListener("DOMContentLoaded", function () {
        console.log('Page loaded, polling magnet URLs...');
        pollMagnetUrls();  // First immediate call when the page loads
        setInterval(pollMagnetUrls, 5000);  // Poll every 5 seconds to quickly respond to available torrents
    });

    async function pollMagnetUrls() {
        try {
            console.log(`Fetching magnet URLs for eth address: ${ethAddress.toLowerCase()}`);
            const response = await fetch(`/magnet_urls/${ethAddress.toLowerCase()}`);
            if (response.ok) {
                const data = await response.json();
                const magnetUrls = data.magnet_urls;

                if (magnetUrls.length > 0) {
                    // Sort videos by snapshot_index to ensure correct order
                    magnetUrls.sort((a, b) => a.snapshot_index - b.snapshot_index);
                    console.log(`Magnet URLs sorted by snapshot index: ${magnetUrls.map(url => url.snapshot_index)}`);
                    streamMagnetUrls(magnetUrls);
                } else {
                    console.error("No magnet URLs found.");
                }
            } else {
                console.error("Failed to fetch magnet URLs:", response.statusText);
            }
        } catch (error) {
            console.error("Error fetching magnet URLs:", error);
        }
    }

    function streamMagnetUrls(magnetUrls) {
        magnetUrls.forEach(({ magnet_url, snapshot_index }) => {
            if (!processedMagnetUrls.has(magnet_url)) {
                downloadAndQueueMagnet(magnet_url, snapshot_index);  // Download video and queue it with snapshot_index
                processedMagnetUrls.add(magnet_url);  // Mark as processed to avoid duplicates
            }
        });
    }

    function downloadAndQueueMagnet(magnetUrl, snapshotIndex) {
        console.log("Processing magnet URL:", magnetUrl);

        client.add(magnetUrl, function (torrent) {
            setupTorrentGraph(torrent);  // Set up graph for torrent download progress

            const file = torrent.files.find(file => file.name.endsWith('.mp4'));

            if (file) {
                console.log(`Found MP4 file in torrent: ${file.name} (Snapshot index: ${snapshotIndex})`);

                file.getBlobURL((err, url) => {
                    if (err) {
                        console.error("Error getting Blob URL:", err);
                        return;
                    }

                    // Add the Blob URL to the queue with the snapshot_index
                    videoQueue.push({ url, snapshotIndex });
                    console.log(`Video (Snapshot index: ${snapshotIndex}) added to queue.`);

                    // Sort the videoQueue by snapshotIndex to ensure correct playback order
                    videoQueue.sort((a, b) => a.snapshotIndex - b.snapshotIndex);

                    // Start playing if not already playing and the queue is ready
                    if (!isPlaying && videoQueue.length > 0) {
                        playNextInQueue();
                    }
                });
            } else {
                console.error("No MP4 file found in the torrent.");
            }
        });
    }

    function playNextInQueue() {
        if (currentVideoIndex < videoQueue.length) {
            const video = videoQueue[currentVideoIndex];
            videoElement.src = video.url;  // Set the video source based on the correct order
            videoElement.load();
            videoElement.play().then(() => {
                console.log(`Playing video with snapshot index: ${video.snapshotIndex}.`);
                isPlaying = true;
            }).catch((error) => {
                console.error("Error playing video:", error);
            });
        } else {
            console.log("No videos in the queue to play.");
        }
    }

    function handleVideoEnd() {
        currentVideoIndex++;
        isPlaying = false;
        
        // If there is another video in the queue, play it
        if (currentVideoIndex < videoQueue.length) {
            playNextInQueue();
        } else {
            console.log("Queue is empty. Polling for more videos...");
        }
    }

    function setupTorrentGraph(torrent) {
        const canvas = document.getElementById('torrent-graph');
        const ctx = canvas.getContext('2d');

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw progress bar
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, 0, canvas.width * torrent.progress, 50);
            ctx.strokeStyle = '#000000';
            ctx.strokeRect(0, 0, canvas.width, 50);

            // Show download speed
            ctx.font = '20px Arial';
            ctx.fillStyle = '#000000';
            ctx.fillText('Download Speed: ' + (torrent.downloadSpeed / 1024).toFixed(2) + ' KB/s', 10, 100);

            // Show upload speed
            ctx.fillText('Upload Speed: ' + (torrent.uploadSpeed / 1024).toFixed(2) + ' KB/s', 10, 150);

            // Show number of peers
            ctx.fillText('Peers: ' + torrent.numPeers, 10, 200);

            requestAnimationFrame(drawGraph);  // Continuously update the graph
        }

        requestAnimationFrame(drawGraph);
    }


    // Load user's profile from GremlinProfile contract
    async function loadUserProfile() {
        try {
            const profile = await gremlinProfileContract.methods.getProfile(ethAddress).call();
            document.getElementById('profile-name').innerText = profile[0];
            const sanitizedHtml = sanitizeHTML(profile[3]);
            document.getElementById('custom-html-content').innerHTML = sanitizedHtml;
        } catch (error) {
            console.error("Error loading user profile:", error);
        }
    }

    // Load user's published papers
    async function loadPublishedPapers() {
        const papersList = document.getElementById("published-papers-list");
        const noPapersMessage = document.getElementById("no-papers-message");

        try {
            const allPaperIds = await gremlinJournalContract.methods.getAllPaperIds("submissionOrder").call();
            let paperCount = 0;

            for (let i = 0; i < allPaperIds.length; i++) {
                const paper = await gremlinJournalContract.methods.getPaperDetails(allPaperIds[i]).call();
                if (paper.author === ethAddress) {
                    paperCount++;
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <strong>Title:</strong> ${paper.title}<br>
                        <strong>Description:</strong> ${paper.description}<br>
                        <strong>Magnet URL:</strong> <a href="${paper.magnetURL}" target="_blank">${paper.magnetURL}</a>
                        <button onclick="seedMagnetUrl('${paper.magnetURL}')" class="btn btn-primary btn-sm">Seed Magnet</button><br>
                    `;
                    papersList.appendChild(listItem);
                }
            }

            if (paperCount === 0) {
                noPapersMessage.style.display = 'block';
            }
        } catch (error) {
            console.error("Error loading published papers:", error);
        }
    }

    // Load user's rating
    async function loadUserRating() {
        try {
            const leaderboard = await gremlinLeaderboardContract.methods.getLeaderboard().call();
            let rating = null;

            for (let i = 0; i < leaderboard.length; i++) {
                if (leaderboard[i].entity === ethAddress) {
                    rating = leaderboard[i].score;
                    break;
                }
            }

            if (rating !== null) {
                document.getElementById('user-rating').innerText = rating;
                document.getElementById('no-rating-message').style.display = 'none';
            } else {
                document.getElementById('no-rating-message').style.display = 'block';
            }
        } catch (error) {
            console.error("Error loading user rating:", error);
        }
    }

    // Load user skills for spider chart
    async function loadUserSkills() {
        try {
            const leaderboard = await gremlinLeaderboardContract.methods.getLeaderboard().call();
            let skills = [0, 0, 0, 0, 0, 0];

            for (let i = 0; i < leaderboard.length; i++) {
                if (leaderboard[i].entity === ethAddress) {
                    skills = [
                        leaderboard[i].score,
                        leaderboard[i].score / 2,
                        leaderboard[i].score / 3,
                        leaderboard[i].score / 1.5,
                        leaderboard[i].score / 4,
                        leaderboard[i].score / 5
                    ];
                    break;
                }
            }

            renderSkillChart(skills);
        } catch (error) {
            console.error("Error loading user skills:", error);
            renderSkillChart([0, 0, 0, 0, 0, 0]);
        }
    }

    function renderSkillChart(skills) {
        const ctx = document.getElementById('skillChart').getContext('2d');
        new Chart(ctx, {
            type: 'radar',
            data: {
                labels: ['Speed', 'Algorithms', 'Data Structures', 'Security', 'Web Development', 'Versatility'],
                datasets: [{
                    label: 'User Skills',
                    data: skills,
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: 'rgba(54, 162, 235, 1)'
                }]
            },
            options: {
                scale: {
                    ticks: {
                        beginAtZero: true,
                        max: 100
                    }
                },
                responsive: true
            }
        });
    }

    // Sanitize HTML content
    function sanitizeHTML(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        const scripts = div.getElementsByTagName('script');
        for (let i = 0; i < scripts.length; i++) {
            scripts[i].remove();
        }
        return div.innerHTML;
    }

    document.addEventListener("DOMContentLoaded", function () {
        loadUserProfile();  // Load user profile data
        loadPublishedPapers();  // Load published papers
        loadUserRating();  // Load user rating
        loadUserSkills();  // Load user skills chart
    });
</script>
{% endblock %}
