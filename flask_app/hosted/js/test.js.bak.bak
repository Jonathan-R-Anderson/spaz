let web3;
let gremlinThreadContract;
let gremlinReplyContract;
let gremlinAdminContract;
let currentAccount = null;
const client = new WebTorrent();
let allThreads = [];
let threadMap = {};
let isAdmin = false;  // Default to non-admin
const addedMagnets = new Set();
let selectedTags = [];
let pyodide = null;
const visibleComments = {};

// Create a popup div
const profilePopup = document.createElement('div');
profilePopup.style.position = 'absolute';
profilePopup.style.width = '300px';   // Set a small size for the mini window
profilePopup.style.height = '200px';  // Adjust the height accordingly
profilePopup.style.backgroundColor = 'white';
profilePopup.style.border = '1px solid #ccc';
profilePopup.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
profilePopup.style.padding = '10px';
profilePopup.style.overflow = 'auto';
profilePopup.style.display = 'none';  // Hidden by default
profilePopup.style.zIndex = '10000';
profilePopup.style.borderRadius = '8px';

window.onload = async function() {
    document.body.appendChild(profilePopup);
    console.log("Window loaded.");
    console.log("Natural library check:", window.natural); // Debug check for natural library
    if (typeof window.ethereum !== 'undefined') {
        console.log("MetaMask detected.");
        web3 = new Web3(window.ethereum);

        gsap.fromTo('#connectWalletIcon', { scale: 0.8 }, { scale: 1.2, duration: 0.5, yoyo: true, repeat: -1, ease: 'power1.inOut' });

        try {
            console.log("Requesting MetaMask accounts...");
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            const accounts = await web3.eth.getAccounts();
            if (accounts.length === 0) {
                document.getElementById('connectWalletIcon').style.display = 'block';
            } else {
                currentAccount = accounts[0];
                document.getElementById('connectWalletIcon').style.display = 'none';
                document.getElementById("status").innerText = `Connected account: ${currentAccount}`;
                await initializePyodide();
                initializeContracts();
                console.log("Gremlin contracts initialized successfully.");
                await checkIfAdmin(currentAccount); 
                await loadAndDisplayThreads();
            }

        } catch (error) {
            console.error('MetaMask access error:', error);
            document.getElementById("status").innerText = 'Could not access MetaMask. Please ensure you have authorized access.';
        }
    } else {
        console.log("MetaMask is not installed.");
        document.getElementById("status").innerText = 'MetaMask is not installed. Please install MetaMask to use this DApp.';
    }
};

document.getElementById('showOverlayBtn').addEventListener('click', function() {
    document.getElementById('replyContext').style.display = 'none';
    document.getElementById('newPostTitle').style.display = 'block';
    document.getElementById('newPostTags').style.display = 'block';
    document.getElementById('overlayTitle').innerText = 'Create a New Post';
    document.getElementById('overlay').style.height = '100%';
    gsap.to(window, { duration: 1, scrollTo: '#overlayContent', ease: 'power2.inOut' });
});

// Attach hover event listeners to the Ethereum address elements
document.addEventListener('DOMContentLoaded', () => {
    const ethAddressElements = document.querySelectorAll('.eth-address'); // Use the class you applied to Ethereum addresses

    ethAddressElements.forEach(el => {
        const ethAddress = el.dataset.ethAddress;
        
        el.addEventListener('mouseenter', (event) => showProfilePopup(event, ethAddress));
        el.addEventListener('mouseleave', hideProfilePopup);
    });
});

async function initializePyodide() {
    if (!pyodide) {
        console.log('Initializing Pyodide...');
        pyodide = await loadPyodide();  // Load Pyodide when the page loads
        console.log('Pyodide initialized.');
    }
}

// Function to fetch and show the profile
async function showProfilePopup(event, ethAddress) {
    try {
        // Fetch the profile HTML from the server
        const response = await fetch(`/users/${ethAddress}`);
        const profileHTML = await response.text();

        // Inject the fetched HTML into the popup
        profilePopup.innerHTML = profileHTML;

        // Position the popup near the cursor
        profilePopup.style.left = `${event.pageX + 10}px`;
        profilePopup.style.top = `${event.pageY + 10}px`;

        // Display the popup
        profilePopup.style.display = 'block';
    } catch (error) {
        console.error("Error fetching profile:", error);
    }
}

// Hide the profile popup when the mouse leaves
function hideProfilePopup() {
    profilePopup.style.display = 'none';
}

function closeOverlay() {
    document.getElementById('newPostTitle').value = '';
    document.getElementById('newPostContent').value = '';
    document.getElementById('newPostTags').value = '';
    document.getElementById('newPostEmail').value = '';
    document.getElementById('imageUpload').value = '';
    document.getElementById('overlay').style.height = '0%';
}

function initializeContracts() {
    gremlinThreadContract = new web3.eth.Contract(_gremlinThreadABI, _gremlinThreadAddress);
    gremlinReplyContract = new web3.eth.Contract(_gremlinReplyABI, _gremlinReplyAddress);
    gremlinAdminContract = new web3.eth.Contract(_gremlinAdminABI, _gremlinAdminAddress);
    console.log("Contract instances created.");
}

function updateTagDisplay() {
    const filterMode = document.querySelector('input[name="filterMode"]:checked').value;
    const tagDisplayTitle = document.getElementById('tagDisplayTitle');
    const tagDisplay = document.getElementById('tagDisplay');

    if (filterMode === 'whitelist') {
        tagDisplayTitle.innerText = "Current Whitelist:";
        tagDisplay.innerHTML = '<li>Example Whitelist Tag 1</li><li>Example Whitelist Tag 2</li>';
    } else if (filterMode === 'blacklist') {
        tagDisplayTitle.innerText = "Current Blacklist:";
        tagDisplay.innerHTML = '<li>Example Blacklist Tag 1</li><li>Example Blacklist Tag 2</li>';
    }
}

function addTagOnEnter(event) {
    if (event.key === 'Enter') {
        const tag = event.target.value.trim();
        if (tag) {
            addTagToSearchBar(tag);
            event.target.value = '';
        }
    }
}

function addTagToSearchBar(tag) {
    const searchBar = document.getElementById('searchTagsDisplay');
    if (selectedTags.includes(tag)) return;

    selectedTags.push(tag);
    const tagButton = document.createElement('button');
    tagButton.innerText = `${tag} X`;
    tagButton.className = 'tag-button';
    tagButton.style.margin = '5px';

    tagButton.onclick = function() {
        selectedTags = selectedTags.filter(selectedTag => selectedTag !== tag);
        searchBar.removeChild(tagButton);
        applyTagFilter();
    };

    searchBar.appendChild(tagButton);
    applyTagFilter();
}

function applyTagFilter() {
    const filterMode = document.querySelector('input[name="filterMode"]:checked').value;
    const allThreadContainers = document.querySelectorAll('.thread-container');

    allThreadContainers.forEach(container => {
        const tagsContainer = container.querySelector('.tags');
        const threadTags = Array.from(tagsContainer.querySelectorAll('.tag')).map(tagElem => tagElem.innerText);

        if (filterMode === 'whitelist') {
            const hasAllTags = selectedTags.every(tag => threadTags.includes(tag));
            container.style.display = hasAllTags ? 'block' : 'none';
        } else if (filterMode === 'blacklist') {
            const hasAnySelectedTag = selectedTags.some(tag => threadTags.includes(tag));
            container.style.display = hasAnySelectedTag ? 'none' : 'block';
        }
    });
}

async function submitPost() {
    const title = document.getElementById('newPostTitle').value.trim() || 'Untitled Post';
    const email = document.getElementById('newPostEmail').value || 'no-email@example.com';
    const content = document.getElementById('newPostContent').value.trim() || 'No content provided';
    const tags = document.getElementById('newPostTags').style.display === 'block'
        ? (document.getElementById('newPostTags').value.split(',').map(tag => tag.trim()) || ['uncategorized'])
        : ['uncategorized'];
    const imageFile = document.getElementById('imageUpload').files[0];

    try {
        let magnetUrl = '';
        if (imageFile) {
            const uploadResponse = await uploadToServer(imageFile);
            magnetUrl = uploadResponse;
        } else {
            magnetUrl = '0';
        }

        const isReply = document.getElementById('replyContext').style.display !== 'none';
        let parentThreadId = isReply ? document.getElementById('replyThreadTitle').dataset.threadId : '0';

        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        const account = accounts[0];

        let contractMethod;
        let gasEstimate;

        if (isReply) {
            contractMethod = gremlinReplyContract.methods.createReply(content, email, magnetUrl, parentThreadId);
        } else {
            contractMethod = gremlinThreadContract.methods.createThread(
                title, title, email, magnetUrl, tags, content, parentThreadId
            );
        }

        gasEstimate = await contractMethod.estimateGas({ from: account });
        await contractMethod.send({ from: account, gas: gasEstimate })
            .on('receipt', function(receipt) {
                console.log('Transaction receipt:', receipt);
            });

        closeOverlay();
        await loadAndDisplayThreads();

    } catch (error) {
        console.error('Error submitting post:', error);
    }
}

function uploadToServer(file) {
    return new Promise((resolve, reject) => {
        const formData = new FormData();
        formData.append('file', file);

        console.log('Uploading file to server...');
        fetch('/upload', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.magnet_url) {
                const magnetUrl = String(data.magnet_url);
                console.log('Server seeding: Magnet URL:', magnetUrl);

                const existingTorrent = client.get(magnetUrl);
                if (existingTorrent) {
                    console.log('Torrent already exists, reusing it:', existingTorrent.infoHash);
                    resolve(magnetUrl);
                } else {
                    const trackerOptions = {
                        announce: ['wss://tracker.openwebtorrent.com']
                    };
                    client.add(magnetUrl, trackerOptions, torrent => {
                        console.log('Torrent added successfully with the specified tracker:', torrent.infoHash);
                        resolve(magnetUrl);
                    });
                }
            } else {
                console.error('Error from server:', data.error || 'Unknown error');
                reject(data.error || 'Unknown error');
            }
        })
        .catch(error => {
            console.error('Error uploading to server:', error);
            reject(error);
        });
    });
}


function organizeThreadsAndReplies(threads, replies) {
    threadMap = {};

    threads.forEach(thread => {
        const threadId = thread.id.toString();
        threadMap[threadId] = { thread: thread, replies: [] };
    });

    replies.forEach(reply => {
        const parentThreadId = reply.parentId.toString();
        console.log('Organizing reply:', reply, 'for parent thread ID:', parentThreadId);

        if (threadMap[parentThreadId]) {
            threadMap[parentThreadId].replies.push(reply);
        } else {
            console.warn(`Reply with parentThreadId ${parentThreadId} has no matching thread.`);
        }
    });

    console.log('Thread map after organizing replies:', threadMap);
}

function displaySortedThreads() {
    const contentDiv = document.getElementById('infiniteScrollContent');
    contentDiv.innerHTML = '';
    const validThreads = Object.values(threadMap).filter(({ thread }) => thread !== null && thread !== undefined);

    if (validThreads.length === 0) {
        console.log("No valid root threads to display.");
        document.getElementById("status").innerText = "No valid root threads found.";
        return;
    }

    const sortedThreads = validThreads.sort((a, b) => {
        const latestA = getLastActivityTimestamp(a);
        const latestB = getLastActivityTimestamp(b);
        return latestB - latestA;
    });

    console.log("Displaying sorted threads...");
    sortedThreads.forEach(({ thread, replies }) => {
        const hierarchicalReplies = generateTFIDFHierarchy(replies);
        displayThreadWithReplies(thread, hierarchicalReplies);
    });
}


function displayThreadWithReplies(thread, hierarchicalReplies) {
    console.log("Displaying thread:", thread);
    console.log(JSON.stringify(hierarchicalReplies, (key, value) => 
        typeof value === 'bigint' ? value.toString() : value, 2));

    const threadContainer = document.createElement('div');
    threadContainer.className = 'thread-container';
    threadContainer.id = `thread-${thread.id}`;

    // Display the thread title and content
    const title = document.createElement('h3');
    title.innerText = `${thread.name}`;
    threadContainer.appendChild(title);
    console.log("Thread title displayed:", thread.name);

    const subject = document.createElement('p');
    subject.innerText = `${thread.subject}`;
    threadContainer.appendChild(subject);
    console.log("Thread subject displayed:", thread.subject);

    const submitter = document.createElement('p');
    submitter.innerText = `Address: ${thread.sender}`;
    threadContainer.appendChild(submitter);
    console.log("Thread submitted by address displayed:", thread.sender);

    const content = document.createElement('div');
    content.innerHTML = renderMarkdown(thread.content);
    threadContainer.appendChild(content);
    console.log("Thread content rendered and displayed.");

    // Display tags for the thread
    const tagsContainer = document.createElement('div');
    tagsContainer.className = 'tags';
    thread.tags.forEach(tag => {
        const tagElement = document.createElement('span');
        tagElement.className = 'tag';
        tagElement.innerText = tag;
        tagElement.onclick = () => addTagToSearchBar(tag);
        tagsContainer.appendChild(tagElement);
    });
    threadContainer.appendChild(tagsContainer);
    console.log("Thread tags displayed:", thread.tags);

    // Reply button for creating replies to this thread
    const replyButton = document.createElement('button');
    replyButton.innerText = "Reply";
    replyButton.onclick = () => openReplyOverlay(thread);
    threadContainer.appendChild(replyButton);
    console.log("Reply button added for the thread.");

    // If there's a magnet URL, download the associated image
    if (thread.magnetUrl && thread.magnetUrl !== '0') {
        console.log("Thread has a magnet URL. Downloading associated image:", thread.magnetUrl);
        downloadImage(thread.magnetUrl, threadContainer);
    } else {
        console.log("No magnet URL found for this thread.");
    }

    // Create a unique container for the radial tree visualization
    const treeContainer = document.createElement('div');
    treeContainer.id = `treeContainer-${thread.id}`;
    treeContainer.style.width = '100%';
    treeContainer.style.height = '600px';
    treeContainer.style.marginTop = '20px';
    threadContainer.appendChild(treeContainer);
    console.log("Radial tree container created for thread ID:", thread.id);

    // Append the thread container to the main content
    document.getElementById('infiniteScrollContent').appendChild(threadContainer);
    console.log("Thread container appended to the infinite scroll content.");

    // Render the radial tree
    //renderRadialPhylogeneticTree(treeContainer.id, hierarchicalReplies);
    renderRadialTreeWithWordCloud(treeContainer.id, hierarchicalReplies);
}



function getLastActivityTimestamp({ thread, replies }) {
    if (!thread) return 0;
    const latestReplyTimestamp = replies.length > 0
        ? Math.max(...replies.map(reply => reply ? Number(reply.timestamp) : 0))
        : 0;
    return Math.max(Number(thread.timestamp), latestReplyTimestamp);
}



function findMostCentralReply(similarityMatrix) {
    // Calculate the sum of similarities for each reply and choose the one with the highest sum
    const totalSimilarities = similarityMatrix.map(row => row.reduce((sum, val) => sum + val, 0));
    const maxIndex = totalSimilarities.indexOf(Math.max(...totalSimilarities));
    return maxIndex;
}



function visualizeReplyAssociations(replies, associations) {
    // Create the visualization container
    const container = d3.select('#treeOfLifeContainer');
    container.html('');  // Clear previous content

    const width = 800;
    const height = 800;

    const svg = container
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', `translate(${width / 2}, ${height / 2})`);

    // Draw nodes for each reply
    const nodes = svg.selectAll('circle')
        .data(replies)
        .enter()
        .append('circle')
        .attr('r', 5)
        .attr('cx', (d, i) => 200 * Math.cos((i / replies.length) * 2 * Math.PI))  // Circular layout
        .attr('cy', (d, i) => 200 * Math.sin((i / replies.length) * 2 * Math.PI))
        .style('fill', '#69b3a2');

    // Draw links between associated replies
    const links = svg.selectAll('line')
        .data(associations)
        .enter()
        .append('line')
        .attr('x1', d => 200 * Math.cos((replies.findIndex(r => r.id === d.source) / replies.length) * 2 * Math.PI))
        .attr('y1', d => 200 * Math.sin((replies.findIndex(r => r.id === d.source) / replies.length) * 2 * Math.PI))
        .attr('x2', d => 200 * Math.cos((replies.findIndex(r => r.id === d.target) / replies.length) * 2 * Math.PI))
        .attr('y2', d => 200 * Math.sin((replies.findIndex(r => r.id === d.target) / replies.length) * 2 * Math.PI))
        .style('stroke', '#ccc')
        .style('stroke-width', d => 2 * d.similarity);
}



// Compute the mean and standard deviation of similarity values
function computeMeanAndStdDev(similarityMatrix) {
    let values = [];
    similarityMatrix.forEach(row => values.push(...row.filter(value => value > 0)));
    const mean = values.reduce((sum, value) => sum + value, 0) / values.length;
    const variance = values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / values.length;
    return { mean, stdDev: Math.sqrt(variance) };
}

// Filtered Similarities function based on high TF-IDF values
function computeFilteredSimilarities(repliesWithTFIDF, tfidfThreshold) {
    const similarityMatrix = [];
    for (let i = 0; i < repliesWithTFIDF.length; i++) {
        similarityMatrix[i] = [];
        for (let j = 0; j < repliesWithTFIDF.length; j++) {
            if (i !== j) {
                const filteredTFIDF1 = filterHighTFIDFTerms(repliesWithTFIDF[i].tfidfData, tfidfThreshold);
                const filteredTFIDF2 = filterHighTFIDFTerms(repliesWithTFIDF[j].tfidfData, tfidfThreshold);
                const similarity = calculateCosineSimilarity(filteredTFIDF1, filteredTFIDF2);
                similarityMatrix[i][j] = similarity;
            } else {
                similarityMatrix[i][j] = 0; // No self-similarity
            }
        }
    }
    return similarityMatrix;
}

// Filter out low TF-IDF values
function filterHighTFIDFTerms(tfidfData, threshold) {
    const filteredTFIDF = {};
    for (const term in tfidfData) {
        if (tfidfData[term] > threshold) {
            filteredTFIDF[term] = tfidfData[term];
        }
    }
    return filteredTFIDF;
}

function buildHierarchy(comments) {
    const commentMap = new Map();

    // Step 1: Map each comment by its ID for quick lookup
    comments.forEach(comment => {
        comment.children = []; // Initialize children
        commentMap.set(comment.id, comment);
    });

    // Step 2: Organize comments into a hierarchy
    const rootComments = [];
    comments.forEach(comment => {
        if (!comment.parentId) {
            // No parentId means it's a direct reply to the root
            rootComments.push(comment);
        } else {
            // Find the parent comment and add this comment as its child
            const parent = commentMap.get(comment.parentId);
            if (parent) {
                parent.children.push(comment);
            }
        }
    });

    return rootComments;
}

function renderRadialPhylogeneticTree(containerId, data) {
    console.log("Starting to render radial phylogenetic tree...");

    const diameter = 800;
    const radius = diameter / 2;

    try {
        // Select the container and clear any existing content
        const svg = d3.select(`#${containerId}`)
            .html("") // Clear previous content
            .append("svg")
            .attr("width", diameter)
            .attr("height", diameter)
            .append("g")
            .attr("transform", `translate(${radius},${radius})`);

        console.log("SVG container initialized.");

        // Convert data into a hierarchy
        const root = d3.hierarchy(data[0], d => d.children); // Start from the first item in the array
        console.log("Hierarchy created:", root);

        // Radial tree layout
        const radialTree = d3.tree()
            .size([2 * Math.PI, radius - 150]); // Define radial size
        radialTree(root);

        console.log("Tree layout applied:", root);

        // Add links between nodes
        svg.selectAll(".link")
            .data(root.links())
            .join("path")
            .attr("class", "link")
            .attr("d", d3.linkRadial()
                .angle(d => d.x)
                .radius(d => d.y))
            .style("fill", "none")
            .style("stroke", "#ccc")
            .style("stroke-width", 1.5);

        console.log("Links added.");

        // Add nodes
        const node = svg.selectAll(".node")
            .data(root.descendants())
            .join("g")
            .attr("class", "node")
            .attr("transform", d => `
                rotate(${d.x * 180 / Math.PI - 90})
                translate(${d.y},0)
            `);

        console.log("Nodes added.");

        // Add circles for nodes
        node.append("circle")
            .attr("r", 4)
            .style("fill", "#69b3a2");

        console.log("Node circles added.");

        // Add text labels
        node.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => d.x < Math.PI ? 6 : -6)
            .attr("text-anchor", d => d.x < Math.PI ? "start" : "end")
            .attr("transform", d => d.x >= Math.PI ? "rotate(180)" : null)
            .text(d => d.data.content.slice(0, 30) + "..."); // Display truncated content
        console.log("Node labels added.");

        console.log("Radial phylogenetic tree rendered successfully.");
    } catch (error) {
        console.error("Error rendering radial phylogenetic tree:", error);
    }
}

function renderRadialTreeWithWordCloud(containerId, data) {
    console.log("Rendering radial tree with word clouds...");

    const diameter = 800;
    const radius = diameter / 2;

    try {
        // Select the container and clear previous content
        const svg = d3.select(`#${containerId}`)
            .html("") // Clear previous content
            .append("svg")
            .attr("width", diameter)
            .attr("height", diameter)
            .append("g")
            .attr("transform", `translate(${radius},${radius})`);

        console.log("SVG container initialized.");

        // Convert data into a hierarchy
        const root = d3.hierarchy(data[0], d => d.children); // Start from the first item in the array
        console.log("Hierarchy created:", root);

        // Radial tree layout
        const radialTree = d3.tree().size([2 * Math.PI, radius - 150]); // Define radial size
        radialTree(root);

        console.log("Tree layout applied:", root);

        // Add links between nodes
        svg.selectAll(".link")
            .data(root.links())
            .join("path")
            .attr("class", "link")
            .attr("d", d3.linkRadial()
                .angle(d => d.x)
                .radius(d => d.y))
            .style("fill", "none")
            .style("stroke", "#ccc")
            .style("stroke-width", 1.5);

        console.log("Links added.");

        // Add nodes with word clouds
        const node = svg.selectAll(".node")
            .data(root.descendants())
            .join("g")
            .attr("class", "node")
            .attr("transform", d => `
                rotate(${(d.x * 180) / Math.PI - 90})
                translate(${d.y},0)
            `);

        console.log("Nodes added.");

        // Generate word clouds for each node
        node.each(function(d) {
            const words = getWordFrequencies(d.data.processedWords || []); // Compute word frequencies
            renderWordCloud(this, words, 50); // Render word cloud in each node
        });

        console.log("Word clouds rendered.");

        // Add labels (optional)
        node.append("text")
            .attr("dy", "0.31em")
            .attr("x", d => (d.x < Math.PI ? 6 : -6))
            .attr("text-anchor", d => (d.x < Math.PI ? "start" : "end"))
            .attr("transform", d => (d.x >= Math.PI ? "rotate(180)" : null))
            .text(d => d.data.content.slice(0, 30) + "...")
            .style("fill", "#000");

        console.log("Labels added.");

    } catch (error) {
        console.error("Error rendering radial tree with word clouds:", error);
    }
}

// Helper function to compute word frequencies
function getWordFrequencies(words) {
    const frequencies = {};
    words.forEach(word => {
        frequencies[word] = (frequencies[word] || 0) + 1;
    });
    return Object.entries(frequencies).map(([word, freq]) => ({ text: word, size: freq }));
}

// Render word cloud for a single node
function renderWordCloud(node, words, maxFontSize) {
    const wordScale = d3.scaleLinear()
        .domain(d3.extent(words, d => d.size))
        .range([10, maxFontSize]); // Scale word sizes

    const wordColor = d3.scaleSequential(d3.interpolateBlues)
        .domain(d3.extent(words, d => d.size)); // Scale word colors

    const layout = d3.layout.cloud()
        .size([100, 100]) // Define cloud size
        .words(words)
        .padding(5)
        .fontSize(d => wordScale(d.size))
        .rotate(() => ~~(Math.random() * 2) * 90) // Rotate words randomly
        .on("end", words => {
            const g = d3.select(node)
                .append("g")
                .attr("transform", "translate(-50, -50)"); // Center word cloud

            g.selectAll("text")
                .data(words)
                .join("text")
                .style("font-size", d => `${d.size}px`)
                .style("fill", d => wordColor(d.size))
                .attr("text-anchor", "middle")
                .attr("transform", d => `translate(${d.x},${d.y}) rotate(${d.rotate})`)
                .text(d => d.text);
        });

    layout.start();
}



// Build hierarchy based on a dynamic threshold
function buildHierarchyWithThreshold(rootIndex, repliesWithTFIDF, similarityMatrix, threshold, visited = new Set()) {
    // Check if the rootIndex is valid and if the reply at that index has an 'id'
    if (visited.has(rootIndex) || !repliesWithTFIDF[rootIndex] || !repliesWithTFIDF[rootIndex].id) {
        return null; // Skip if reply is invalid or already visited
    }
    
    visited.add(rootIndex);
    
    const rootReply = repliesWithTFIDF[rootIndex];
    const root = {
        name: `Reply ID: ${rootReply.id}`,
        content: rootReply.content,
        children: []
    };

    // Find children of the current root based on dynamic threshold
    similarityMatrix[rootIndex].forEach((similarity, idx) => {
        if (idx !== rootIndex && similarity >= threshold && !visited.has(idx) && repliesWithTFIDF[idx]) {
            const childHierarchy = buildHierarchyWithThreshold(idx, repliesWithTFIDF, similarityMatrix, threshold, visited);
            if (childHierarchy) root.children.push(childHierarchy);
        }
    });

    return root;
}

function bigIntReplacer(key, value) {
    if (typeof value === 'bigint') {
        return value.toString(); // Convert BigInt to string
    }
    return value; // Return other types unchanged
}


function convertBigIntToString(obj) {
    if (typeof obj === 'bigint') {
        return obj.toString(); // Convert BigInt to string
    } else if (Array.isArray(obj)) {
        return obj.map(convertBigIntToString); // Recursively process arrays
    } else if (typeof obj === 'object' && obj !== null) {
        return Object.fromEntries(
            Object.entries(obj).map(([key, value]) => [key, convertBigIntToString(value)])
        ); // Recursively process objects
    } else {
        return obj; // Return other types as is
    }
}


// Toggle collapse/expand state
function toggleCollapse(containerId) {
    const container = document.getElementById(containerId);
    const comments = container.querySelectorAll('.comment');

    comments.forEach((comment, index) => {
        if (index >= 3) {
            comment.classList.toggle('collapsed');
        }
    });
}

function generateTFIDFHierarchy(replies) {
    const stopWords = new Set([
        'a', 'an', 'the', 'and', 'or', 'but', 'on', 'in', 'with', 'at', 'of', 'to', 'from', 'by', 'for'
    ]);

    // Helper function for stemming words (basic Porter Stemmer implementation)
    function stemWord(word) {
        return word.replace(/(ing|ed|es|s)$/i, ''); // Simple stemming for common suffixes
    }

    // Tokenize, filter, and normalize words
    function processText(text) {
        return text
            .toLowerCase()
            .replace(/[^\w\s]/g, '') // Remove punctuation
            .split(/\s+/)
            .filter(word => !stopWords.has(word)) // Remove stopwords
            .map(stemWord); // Apply stemming
    }

    // Step 1: Calculate TF-IDF for replies
    const tfidfVectors = calculateTFIDF(replies.map(reply => reply.content));
    const repliesWithTFIDF = replies.map((reply, index) => ({
        ...reply,
        tfidfData: tfidfVectors[index],
        processedWords: Object.keys(tfidfVectors[index]), // Extract words from the TF-IDF vector
    }));

    //console.log('Replies with TF-IDF and metadata:', repliesWithTFIDF);

    // Step 2: Generate the initial vocabulary
    const vocabulary = new Set(repliesWithTFIDF.flatMap(reply => reply.processedWords));
    console.log('Vocabulary:', vocabulary);

    // Step 3: Build the hierarchical structure
    const hierarchy = buildHierarchy(repliesWithTFIDF, vocabulary);
    //console.log('Hierarchy:', JSON.stringify(hierarchy, null, 2));
    return hierarchy;

    function buildHierarchy(replies, vocabulary) {
        if (replies.length === 0) return [];

        // Step 1: Score replies based on vocabulary collisions
        replies.forEach(reply => {
            reply.score = reply.processedWords.reduce((sum, word) => sum + (vocabulary.has(word) ? 1 : 0), 0);
        });

        // Step 2: Find potential parent nodes (above threshold)
        const avgScore = replies.reduce((sum, reply) => sum + reply.score, 0) / replies.length || 0;
        const parentCandidates = replies.filter(reply => reply.score > avgScore);

        if (parentCandidates.length === 0) return replies.map(replyToTreeNode);

        // Choose the node with the highest score as the parent
        const parentNode = parentCandidates.reduce((best, curr) => (curr.score > best.score ? curr : best), parentCandidates[0]);

        // Step 3: Partition replies into children and siblings
        const children = replies.filter(reply => reply !== parentNode && isChild(reply, parentNode));
        const siblings = replies.filter(reply => reply !== parentNode && !children.includes(reply));

        // Step 4: Recur for children and siblings
        parentNode.children = buildHierarchy(children, new Set(children.flatMap(reply => reply.processedWords)));

        return [replyToTreeNode(parentNode), ...buildHierarchy(siblings, vocabulary)];
    }

    function isChild(child, parent) {
        // Determine if a node should be a child of another node
        const sharedKeywords = child.processedWords.filter(word => parent.processedWords.includes(word));
        const overlap = sharedKeywords.length / child.processedWords.length;
        return overlap > 0.2; // Require at least 20% keyword overlap to be considered a child
    }

    function replyToTreeNode(reply) {
        return {
            id: reply.id,
            content: reply.content,
            score: reply.score,
            processedWords: reply.processedWords, // Include processedWords in the tree
            children: reply.children || [],
        };
    }

    function calculateTFIDF(documents) {
        const tokenizedDocs = documents.map(processText);
        const idf = calculateIDF(tokenizedDocs);

        return tokenizedDocs.map(doc => {
            const tf = calculateTF(doc);
            const tfidf = {};
            Object.keys(tf).forEach(term => {
                tfidf[term] = tf[term] * (idf[term] || 0);
            });
            return tfidf;
        });
    }

    function calculateIDF(documents) {
        const documentCount = documents.length;
        const termDocumentCounts = {};

        documents.forEach(doc => {
            const uniqueTerms = new Set(doc);
            uniqueTerms.forEach(term => {
                termDocumentCounts[term] = (termDocumentCounts[term] || 0) + 1;
            });
        });

        const idf = {};
        Object.keys(termDocumentCounts).forEach(term => {
            idf[term] = Math.log(documentCount / (termDocumentCounts[term] || 1));
        });
        return idf;
    }

    function calculateTF(terms) {
        const termCounts = {};
        terms.forEach(term => {
            termCounts[term] = (termCounts[term] || 0) + 1;
        });
        const totalTerms = terms.length;
        const tf = {};
        Object.keys(termCounts).forEach(term => {
            tf[term] = termCounts[term] / totalTerms;
        });
        return tf;
    }
}





function removeCircularReferences(node) {
    const clone = { ...node }; // Shallow copy the node to avoid mutating the original
    delete clone.parent; // Remove the circular reference

    // Recursively process children if they exist
    if (clone.children) {
        clone.children = clone.children.map(removeCircularReferences);
    }
    return clone;
}


function buildHierarchyFromReply(rootIndex, repliesWithTFIDF, similarityMatrix, visited = new Set()) {
    if (visited.has(rootIndex) || !repliesWithTFIDF[rootIndex] || !repliesWithTFIDF[rootIndex].id) {
        console.warn(`Skipping rootIndex ${rootIndex} - Invalid or already visited.`);
        return null;
    }

    visited.add(rootIndex);

    const rootReply = repliesWithTFIDF[rootIndex];
    console.log(`Building hierarchy from root reply ID: ${rootReply.id}`);

    const root = {
        name: `Reply ID: ${rootReply.id}`,
        content: rootReply.content,
        children: []
    };

    const threshold = 0.5;
    similarityMatrix[rootIndex].forEach((similarity, idx) => {
        if (idx !== rootIndex && similarity >= threshold && !visited.has(idx) && repliesWithTFIDF[idx]) {
            console.log(`Adding child reply ID: ${repliesWithTFIDF[idx].id} with similarity: ${similarity}`);
            const childHierarchy = buildHierarchyFromReply(idx, repliesWithTFIDF, similarityMatrix, visited);
            if (childHierarchy) root.children.push(childHierarchy);
        }
    });

    console.log(`Hierarchy for root reply ID ${rootReply.id}:`, root);
    return root;
}

function showCommentsForNode(comments, threadId) {
    // Check if there are any comments
    if (!comments || comments.length === 0) {
        console.log("No comments available for this node.");
        return;
    }

    // Create or select the comment listing container for the thread
    let commentsContainer = document.getElementById(`commentListing-${threadId}`);
    if (!commentsContainer) {
        commentsContainer = document.createElement('div');
        commentsContainer.id = `commentListing-${threadId}`;
        commentsContainer.className = 'comment-listing';
        document.getElementById(`treeContainer-${threadId}`).appendChild(commentsContainer);
    }

    // Render comments in the comments container
    renderComments(comments, commentsContainer.id);
    console.log("Displayed comments for node:", comments);
}



// Render comments in horizontal, expandable layout with collapse/expand functionality
function renderComments(comments, containerId) {
    const container = document.getElementById(containerId);
    container.innerHTML = ''; // Clear previous comments

    comments.forEach((comment, index) => {
        const commentDiv = document.createElement('div');
        commentDiv.classList.add('comment');
        commentDiv.innerText = comment.content;

        // Initially collapse if more than 3 comments
        if (index >= 3) {
            commentDiv.classList.add('collapsed');
        }

        container.appendChild(commentDiv);
    });

    // Add an expand button if there are more than 3 comments
    if (comments.length > 3) {
        const expandButton = document.createElement('button');
        expandButton.innerText = "Show more";
        expandButton.onclick = () => toggleCollapse(containerId);
        container.appendChild(expandButton);
    }

    // Set up horizontal scroll display
    container.style.display = 'flex';
    container.style.overflowX = 'auto';
}

// Toggle collapse/expand for comments
function toggleCollapse(containerId) {
    const container = document.getElementById(containerId);
    const comments = container.querySelectorAll('.comment');

    comments.forEach((comment, index) => {
        if (index >= 3) {
            comment.classList.toggle('collapsed');
        }
    });
}

// CSS styles for collapsed comments (place in your CSS file or inline in a <style> tag)
const style = document.createElement('style');
style.innerHTML = `
    .collapsed {
        display: none;
    }
    .comment {
        margin-right: 10px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f9f9f9;
    }
`;
document.head.appendChild(style);

function visualizeRepliesInThread(replies) {
    const repliesWithTFIDF = calculateTFIDFForThread(replies);
    const similarityMatrix = computeSimilaritiesBetweenReplies(repliesWithTFIDF);
    const associations = createAssociationsFromSimilarities(repliesWithTFIDF, similarityMatrix);

    visualizeReplyAssociations(repliesWithTFIDF, associations);
}


function displayReply(reply, repliesContainer) {
    if (!reply) return;

    const replyContainer = document.createElement('div');
    replyContainer.className = 'reply-container';

    // Display the reply ID
    const replyID = document.createElement('p');
    replyID.innerText = `Reply ID: ${reply.id}`;
    replyContainer.appendChild(replyID);

    const replyContent = document.createElement('p');
    replyContent.innerHTML = renderMarkdown(reply.content); // Render markdown including code
    replyContainer.appendChild(replyContent);

    const submitter = document.createElement('p');
    submitter.innerHTML = `<a href="/users/${reply.sender}" class="eth-address" data-eth-address="${reply.sender}">${reply.sender}</a>`;
    replyContainer.appendChild(submitter);

    if (reply.magnetUrl && reply.magnetUrl !== '0') {
        downloadImage(reply.magnetUrl, replyContainer);
    }

    repliesContainer.appendChild(replyContainer);

    // Add hover event listeners immediately after adding the Ethereum address to the DOM
    const ethAddressSpan = submitter.querySelector('.eth-address');
    const ethAddress = ethAddressSpan.dataset.ethAddress;

    ethAddressSpan.addEventListener('mouseenter', (event) => showProfilePopup(event, ethAddress));
    ethAddressSpan.addEventListener('mouseleave', hideProfilePopup);
}


function renderMarkdown(text) {
    const converter = new showdown.Converter({
        extensions: [
            function() {
                return [{
                    type: 'lang',
                    regex: /```([^]+?)```/g, // Match code blocks between triple backticks
                    replace: function(match, codeContent) {
                        // Clean up any accidental HTML <br> or whitespace added
                        codeContent = codeContent.trim();
                        return `<pre><code data-lang="python">${codeContent}</code></pre>`;
                    }
                }];
            }
        ],
        tables: true,
        strikethrough: true,
        tasklists: true,
        simpleLineBreaks: true
    });

    // Convert the remaining markdown text
    return converter.makeHtml(text);
}

function downloadImage(magnetURI, threadContainer) {
    // Create and append a placeholder paragraph indicating the image is being downloaded
    const output = document.createElement('p');
    output.innerText = 'Downloading image...';
    threadContainer.appendChild(output);

    const trackerOptions = {
        announce: ['wss://tracker.openwebtorrent.com']
    };

    // Check if the torrent already exists in the client
    const existingTorrent = client.get(magnetURI);

    if (existingTorrent) {
        // If the torrent is already in the client, reuse it
        console.log(`Reusing existing torrent: ${magnetURI}`);
        renderImageForAllOccurrences(existingTorrent, magnetURI, threadContainer);
    } else {
        // If the torrent is not in the client, add it and render the image upon completion
        console.log(`Adding new torrent: ${magnetURI}`);
        client.add(magnetURI, trackerOptions, (torrent) => {
            console.log(`Torrent added: ${torrent.infoHash}`);
            renderImageForAllOccurrences(torrent, magnetURI, threadContainer);
        }).on('error', (err) => {
            // Log any errors during the torrent addition process
            console.error(`Error adding torrent: ${err.message}`);
            output.innerText = `Failed to download image: ${err.message}`;
        });
    }
}


function renderImageForAllOccurrences(torrent, magnetURI, threadContainer) {
    // Loop through all files in the torrent
    torrent.files.forEach(file => {
        file.getBlob((err, blob) => {
            if (err) {
                console.error('Error downloading image:', err);
                return;
            }

            // Log the Blob object to make sure it's being generated correctly
            console.log(`Generated Blob object: ${blob} for file: ${file.name}`);

            // Create the Blob URL from the file
            const url = URL.createObjectURL(blob);

            // Check if threadContainer exists
            if (!threadContainer) {
                console.error('Error: threadContainer is undefined or null');
                return;
            }

            // Create a magnet info paragraph
            const magnetInfo = document.createElement('p');
            magnetInfo.innerText = `Magnet URL: ${magnetURI}, Filename: ${file.name}`;

            // Create the image element
            const img = document.createElement('img');
            img.src = url;
            img.alt = file.name;
            img.style.maxWidth = '200px';
            img.style.cursor = 'pointer';
            img.onclick = () => openImageFullScreen(url); // Open in full screen on click

            // Insert the image and magnet info into the container
            const contentSection = threadContainer.querySelector('p + p'); // Adjust based on where you want to insert
            if (contentSection) {
                threadContainer.insertBefore(magnetInfo, contentSection.nextSibling);
                threadContainer.insertBefore(img, magnetInfo.nextSibling);
            } else {
                threadContainer.appendChild(magnetInfo);
                threadContainer.appendChild(img);
            }

            // Log the successful image insertion
            console.log('Image successfully inserted into the DOM');
        });
    });
}


function openImageFullScreen(url) {
    const overlayDiv = document.createElement('div');
    overlayDiv.style.position = 'fixed';
    overlayDiv.style.top = '0';
    overlayDiv.style.left = '0';
    overlayDiv.style.width = '100%';
    overlayDiv.style.height = '100%';
    overlayDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
    overlayDiv.style.zIndex = '10000';
    overlayDiv.style.display = 'flex';
    overlayDiv.style.justifyContent = 'center';
    overlayDiv.style.alignItems = 'center';

    const fullScreenImage = document.createElement('img');
    fullScreenImage.src = url;
    fullScreenImage.style.maxWidth = '90%';
    fullScreenImage.style.maxHeight = '90%';

    overlayDiv.appendChild(fullScreenImage);
    document.body.appendChild(overlayDiv);

    overlayDiv.onclick = () => {
        document.body.removeChild(overlayDiv);
    };
}

function openReplyOverlay(thread) {
    document.getElementById('replyContext').style.display = 'block';
    document.getElementById('replyThreadTitle').innerText = thread.name;
    document.getElementById('replyThreadTitle').dataset.threadId = thread.id;
    document.getElementById('overlayTitle').innerText = 'Reply to Thread';
    document.getElementById('overlay').style.height = '100%';

    document.getElementById('newPostTitle').value = thread.name;
    document.getElementById('newPostTags').style.display = 'none';
}

async function checkIfAdmin(account) {
    try {
        const admin = await gremlinAdminContract.methods.owner().call();
        console.log("Admin address from contract:", admin);
        console.log("Current connected account:", account);

        if (admin.toLowerCase() === account.toLowerCase()) {
            isAdmin = true;
            console.log("User is admin:", isAdmin);
            document.getElementById('adminPanel').style.display = 'block';
        } else {
            console.log("User is not admin:", isAdmin);
        }
    } catch (error) {
        console.error("Error during admin check:", error);
    }
}


// Function to calculate cosine similarity between two TF-IDF vectors
function calculateCosineSimilarity(tfidf1, tfidf2) {
    const commonTerms = Object.keys(tfidf1).filter(term => term in tfidf2);

    const dotProduct = commonTerms.reduce((sum, term) => sum + tfidf1[term] * tfidf2[term], 0);
    const magnitude1 = Math.sqrt(Object.values(tfidf1).reduce((sum, val) => sum + val * val, 0));
    const magnitude2 = Math.sqrt(Object.values(tfidf2).reduce((sum, val) => sum + val * val, 0));

    return dotProduct / (magnitude1 * magnitude2);
}


// Separate function to initialize Ace Editors after new blockchain data is fetched
function initializeCodeEditors() {
    console.log("Initializing Ace editors...");

    const codeBlocks = document.querySelectorAll('pre code[data-lang="python"]');
    console.log(`Found ${codeBlocks.length} <pre><code> blocks.`);

    codeBlocks.forEach((codeBlock, index) => {
        const codeContent = codeBlock.textContent.trim();
        console.log(`Processing code block ${index + 1}:`, codeContent);

        // Create a container div for the editor and buttons
        const editorContainer = document.createElement('div');
        editorContainer.classList.add('code-container');
        editorContainer.innerHTML = `
            <div id="editor-${index}" class="code-editor"></div>
            <button class="run-button" onclick="runPythonCode(${index})">Run Code</button>
            <div id="output-${index}" class="output">Output will be shown here...</div>
        `;

        // Replace the <pre> element with the editor container
        const preTag = codeBlock.closest('pre');
        if (preTag) {
            preTag.replaceWith(editorContainer);
            console.log(`Replaced <pre><code> block ${index + 1} with Ace editor.`);
        } else {
            console.error(`No <pre> tag found for code block ${index + 1}.`);
        }

        // Initialize Ace editor
        const editor = ace.edit(`editor-${index}`);
        editor.session.setMode("ace/mode/python");
        editor.setTheme("ace/theme/monokai");
        editor.setValue(codeContent, -1);  // Insert code content and move cursor to the end
        editor.setOptions({
        fontSize: "16pt"  // Change to desired font size
        });

        // Attach editor to global variable for later access
        window[`editor_${index}`] = editor;

        console.log(`Ace Editor initialized for block ${index + 1}.`);
    });
}


// Function to calculate the average and standard deviation of collision rates
function computeStatistics(collisionRates) {
    const avg = collisionRates.reduce((sum, rate) => sum + rate, 0) / collisionRates.length;
    const variance = collisionRates.reduce((sum, rate) => sum + Math.pow(rate - avg, 2), 0) / collisionRates.length;
    const stdDev = Math.sqrt(variance);
    return { average: avg, stdDev: stdDev };
}


function calculateTFIDFForThread(replies) {
    // Tokenize and calculate TF-IDF for all replies in the thread
    const documents = replies.map(reply => reply.content);  // Collect the content of each reply
    const tfidfVectors = calculateTFIDF(documents);  // Calculate TF-IDF for the set of replies
    console.log("tfidfvectors", tfidfVectors);
    // Attach TF-IDF vectors back to the original replies
    return replies.map((reply, index) => {
        return { ...reply, tfidfData: tfidfVectors[index] };  // Attach TF-IDF data to each reply
    });
}


function createAssociationsFromSimilarities(repliesWithTFIDF, similarityMatrix, threshold = 0.2) {
    const associations = [];

    for (let i = 0; i < similarityMatrix.length; i++) {
        for (let j = 0; j < similarityMatrix[i].length; j++) {
            if (similarityMatrix[i][j] >= threshold) {
                associations.push({
                    source: repliesWithTFIDF[i].id,
                    target: repliesWithTFIDF[j].id,
                    similarity: similarityMatrix[i][j]
                });
            }
        }
    }

    return associations;
}



function computeSimilaritiesBetweenReplies(repliesWithTFIDF) {
    const similarityMatrix = [];

    // Calculate cosine similarity between each pair of replies
    for (let i = 0; i < repliesWithTFIDF.length; i++) {
        similarityMatrix[i] = [];
        for (let j = 0; j < repliesWithTFIDF.length; j++) {
            if (i !== j) {
                const similarity = calculateCosineSimilarity(repliesWithTFIDF[i].tfidfData, repliesWithTFIDF[j].tfidfData);
                similarityMatrix[i][j] = similarity;
            } else {
                similarityMatrix[i][j] = 0;  // No self-similarity
            }
        }
    }

    return similarityMatrix;
}

async function loadAndDisplayThreads() {
    try {
        console.log("Fetching threads and replies from the blockchain...");

        // Fetch threads and replies
        const allFetchedThreads = await gremlinThreadContract.methods.getAllThreads().call();
        console.log("Fetched threads:", allFetchedThreads);

        const allFetchedReplies = await gremlinReplyContract.methods.getAllReplies().call();
        console.log("Fetched replies:", allFetchedReplies);

        // Organize threads and replies
        organizeThreadsAndReplies(allFetchedThreads, allFetchedReplies);
        console.log("Organized threads and replies in threadMap:", threadMap);

        // Display sorted threads
        console.log("Displaying sorted threads...");
        displaySortedThreads();

        // Initialize reply associations with TF-IDF for each thread
        console.log("Initializing reply associations with TF-IDF for each thread...");
        Object.keys(threadMap).forEach(threadId => {
            const { replies } = threadMap[threadId];
            console.log(`Processing thread ID: ${threadId} with replies count: ${replies.length}`);
            if (replies && replies.length > 0) {
                visualizeRepliesInThread(replies);
            } else {
                console.warn(`No replies found for thread ID: ${threadId}`);
            }
        });

        // Initialize code editors for any code blocks in threads
        console.log("Initializing code editors...");
        initializeCodeEditors();

    } catch (error) {
        console.error("Error loading threads:", error);
        document.getElementById("status").innerText = `Error loading threads: ${error.message}`;
    }
}

// Function to run the Python code from Ace Editor
function runPythonCode(editorIndex) {
    console.log(`Running code from editor-${editorIndex}...`);
    
    const editor = window[`editor_${editorIndex}`];
    if (!editor) {
        console.error(`Editor not found for index ${editorIndex}.`);
        return;
    }

    const code = editor.getValue();
    console.log(`Code from editor-${editorIndex}:`, code);

    const outputDiv = document.getElementById(`output-${editorIndex}`);
    if (!outputDiv) {
        console.error(`Output div not found for editor-${editorIndex}.`);
        return;
    }

    // Simulate Python execution and display result
    try {
        const result = evalPythonCode(code);  // Replace with real Python backend call
        outputDiv.textContent = result;
        console.log(`Execution result for editor-${editorIndex}:`, result);
    } catch (error) {
        outputDiv.textContent = `Error: ${error.message}`;
        console.error(`Error executing code from editor-${editorIndex}:`, error);
    }
}

// Dummy function to simulate Python execution
function evalPythonCode(code) {
    // Simulate some basic code execution
    if (code.includes("hello")) {
        return 'Hello, World!';
    }
    return 'Python code executed successfully.';
}


async function importPublicKey(pem) {
    const binaryDer = str2ab(pem);
    return crypto.subtle.importKey(
        "spki",
        binaryDer,
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
    );
}

// Function to convert base64 PEM to binary
function str2ab(str) {
    const binaryString = window.atob(str);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

// Generate HMAC using WebCrypto
async function generateHMAC(secret, data) {
    const key = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(secret),
        { name: "HMAC", hash: "SHA-256" },
        true,
        ["sign"]
    );
    const signature = await crypto.subtle.sign(
        "HMAC",
        key,
        new TextEncoder().encode(data)
    );
    return bufferToHex(signature);
}

// Convert ArrayBuffer to Hex string
function bufferToHex(buffer) {
    const byteArray = new Uint8Array(buffer);
    return Array.prototype.map.call(byteArray, x => ('00' + x.toString(16)).slice(-2)).join('');
}

// Fetch the public key and generate HMAC on frontend
async function fetchPublicKeyAndGenerateHMAC() {
    const ethAddress = "user_ethereum_address";  // e.g., get from MetaMask

    // Fetch the public key from the backend
    const response = await fetch('/start_session', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ eth_address: ethAddress })
    });
    const data = await response.json();

    // Import the public key (ECC)
    const publicKey = await importPublicKey(data.public_key);

    // Generate HMAC using WebCrypto
    const hmacKey = "secret_key";  // Retrieved from backend
    const hmac = await generateHMAC(hmacKey, ethAddress);

    // Encrypt the HMAC using the ECC public key
    const encryptedHMAC = await encryptHMACWithPublicKey(hmac, publicKey);

    // Send the encrypted HMAC back to the server for verification
    await sendEncryptedHMAC(encryptedHMAC, ethAddress);
}

// Function to encrypt HMAC with the public key using ECDH
async function encryptHMACWithPublicKey(hmac, publicKey) {
    // Encryption logic using WebCrypto with the public key
    const encrypted = await crypto.subtle.encrypt(
        { name: "ECDH", public: publicKey },
        publicKey,  // Derived public key
        new TextEncoder().encode(hmac)
    );
    return btoa(String.fromCharCode.apply(null, new Uint8Array(encrypted)));
}

// Send the encrypted HMAC back to the server
async function sendEncryptedHMAC(encryptedHMAC, ethAddress) {
    await fetch('/verify', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ eth_address: ethAddress, encrypted_hmac: encryptedHMAC })
    });
}

function calculateCosineSimilarity(tfidf1, tfidf2) {
    const commonTerms = Object.keys(tfidf1).filter(term => term in tfidf2);

    const dotProduct = commonTerms.reduce((sum, term) => sum + (tfidf1[term] * tfidf2[term]), 0);
    const magnitude1 = Math.sqrt(Object.values(tfidf1).reduce((sum, val) => sum + val * val, 0));
    const magnitude2 = Math.sqrt(Object.values(tfidf2).reduce((sum, val) => sum + val * val, 0));

    return dotProduct / (magnitude1 * magnitude2);
}