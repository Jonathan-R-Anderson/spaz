===== ./api/routes.py =====
from flask import Blueprint
blueprint = Blueprint('main', __name__)
from . import views


===== ./api/__init__.py =====
from .user import User
from .magnet import MagnetURL


===== ./api/views.py =====
# blueprints/views.py
from flask import request, jsonify
from .routes import blueprint
from shared import db, User, MagnetURL, logging
from services import (
    _clear_magnet_urls, _generate_secret, _hash_secret,
    _store_secret, _store_magnet_url, _fetch_secret_from_api
)


import hmac

@blueprint.route('/get_secret/<eth_address>', methods=['GET'])
def get_secret(eth_address):
    logging.info(f"[get_secret] Received request to fetch secret for: {eth_address}")
    try:
        user = User.query.filter_by(eth_address=eth_address).first()
        if user:
            logging.info(f"[get_secret] Secret found for {eth_address}")
            return jsonify({"eth_address": eth_address, "secret": user.rtmp_secret}), 200
        else:
            logging.warning(f"[get_secret] No secret found for {eth_address}")
            return jsonify({"error": "Secret not found"}), 404
    except Exception as e:
        logging.error(f"[get_secret] Failed to fetch secret for {eth_address}: {e}")
        return jsonify({"error": "Internal server error"}), 500



@blueprint.route('/get_magnet_urls/<eth_address>', methods=['GET'])
def retrieve_magnet_urls(eth_address):
    urls = MagnetURL.query.filter_by(eth_address=eth_address).order_by(MagnetURL.snapshot_index).all()
    logging.info(f"data from db {urls}")
    if urls:
        return jsonify({
            "message": "success",
            "eth_address": eth_address,
            "magnet_urls": [
                {"magnet_url": url.magnet_url, "snapshot_index": url.snapshot_index, "created_at": url.created_at}
                for url in urls
            ]
        }), 200
    else:
        return jsonify({"message": "failure"}), 500 

# API to generate and store a new secret
@blueprint.route('/generate_secret', methods=['POST'])
def generate_and_store_secret():
    logging.info("===== [START] /generate_secret =====")

    try:
        data = request.get_json()
        logging.info(f"Incoming JSON payload: {data}")

        eth_address = data.get('eth_address') if data else None
        ip_address = data.get('ip_address') if data else None

        if not eth_address:
            logging.warning("Missing Ethereum address in request.")
            return jsonify({"error": "Missing Ethereum address"}), 400

        if not ip_address:
            logging.warning("Missing IP address in request.")
            return jsonify({"error": "Missing IP address"}), 400

        logging.info(f"Generating secret for eth_address: {eth_address}, ip_address: {ip_address}")
        secret = _generate_secret()
        logging.info(f"Generated plaintext secret: {secret}")

        logging.info("Storing secret in database...")
        _store_secret(eth_address, secret, ip_address)
        logging.info("Successfully stored secret in DB.")

        logging.info("===== [END] /generate_secret =====")
        return jsonify({"eth_address": eth_address, "secret": secret}), 200

    except Exception as e:
        logging.exception(f"Unhandled exception in /generate_secret: {e}")
        return jsonify({"error": "Internal server error"}), 500


@blueprint.route('/get_rtmp_url/<eth_address>', methods=['GET'])
def get_rtmp_url(eth_address):
    logging.info(f"[get_rtmp_url] Received request to build RTMP URL for: {eth_address}")
    try:
        user = User.query.filter_by(eth_address=eth_address).first()
        if user:
            secret = user.rtmp_secret
            rtmp_url = f"rtmp://psichos.is:1935/live/{eth_address}?secret={secret}"
            logging.info(f"[get_rtmp_url] Returning RTMP URL: {rtmp_url}")
            return jsonify({"rtmp_url": rtmp_url}), 200
        else:
            logging.warning(f"[get_rtmp_url] No user found for {eth_address}")
            return jsonify({"error": "Secret not found"}), 404
    except Exception as e:
        logging.error(f"[get_rtmp_url] Exception while fetching RTMP URL: {e}")
        return jsonify({"error": "Internal server error"}), 500


# API to store a magnet URL
@blueprint.route('/store_magnet_url', methods=['POST'])
def store_magnet_url_route():
    data = request.json
    eth_address = data.get('eth_address')
    magnet_url = data.get('magnet_url')
    snapshot_index = data.get('snapshot_index')

    if not eth_address or not magnet_url or snapshot_index is None:
        return jsonify({"error": "Missing required fields"}), 400

    return _store_magnet_url(eth_address, magnet_url, snapshot_index)




# API to clear all magnet URLs for a specific eth_address
@blueprint.route('/clear_magnet_urls/<eth_address>', methods=['DELETE'])
def clear_magnet_urls_route(eth_address):
    return _clear_magnet_urls(eth_address)


# API to store streamer information (eth_address, secret, and IP address)
@blueprint.route('/store_streamer_info', methods=['POST'])
def store_streamer_info():
    data = request.json
    eth_address = data.get('eth_address')
    secret = data.get('secret')
    ip_address = data.get('ip_address')

    logging.info(f"Storing streamer info: eth_address={eth_address}, secret={secret}, ip_address={ip_address}")


    if not eth_address or not secret or not ip_address:
        return jsonify({"error": "Missing required fields"}), 400


    try:
        # Store or update the streamer information in the PostgreSQL database
        user = User.query.filter_by(eth_address=eth_address).first()
        if user:
            # Update the existing record with the new secret and ip_address
            user.rtmp_secret = secret
            # Assuming you have an IP column in the database
            user.ip_address = ip_address  # You would need to add this field in the model
        else:
            # Create a new user record if it doesn't exist
            user = User(eth_address, secret)
            user.ip_address = ip_address  # Set the IP address

        db.session.add(user)
        db.session.commit()
        return jsonify({"message": "Streamer info stored successfully"}), 200
    except Exception as e:
        logging.error(f"Failed to store streamer info: {str(e)}")
        db.session.rollback()
        return jsonify({"error": "Failed to store streamer info"}), 500

# API to get the streamer's IP address based on their Ethereum address
@blueprint.route('/get_streamer_eth_address/<ip_address>', methods=['GET'])
def get_streamer_ip(ip_address):
    try:
        # Query the database for the user based on the Ethereum address
        user = User.query.filter_by(ip_address=ip_address).first()

        if user:
            # Return the IP address if the user is found
            return jsonify({"eth_address": user.eth_address, "ip_address": user.ip_address}), 200
        else:
            # Return an error if the user is not found
            return jsonify({"error": f"No streamer found with Ethereum address: {ip_address}"}), 404
    except Exception as e:
        logging.error(f"Failed to retrieve IP address for {ip_address}: {str(e)}")
        return jsonify({"error": "Failed to retrieve IP address"}), 500

@blueprint.route('/verify_secret', methods=['POST'])
def verify_secret():
    if request.is_json:
        eth_address = request.json.get('eth_address')
        secret = request.json.get('secret')
    else:
        stream_key = request.args.get('name') or request.form.get('name')
        if not stream_key or '&' not in stream_key:
            return '', 403
        try:
            eth_address, secret = stream_key.split('&secret=')
        except Exception:
            return '', 403

    if not eth_address or not secret:
        return '', 403

    stored_secret = _fetch_secret_from_api(eth_address)
    if not stored_secret:
        return '', 403

    if hmac.compare_digest(secret, stored_secret):
        return '', 204
    else:
        return '', 403




===== ./models/user.py =====
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    eth_address = db.Column(db.String(42), unique=True, nullable=False)
    rtmp_secret = db.Column(db.String(64), nullable=False)
    ip_address = db.Column(db.String(45), nullable=False)

    def __init__(self, eth_address, rtmp_secret, ip_address):
        self.eth_address = eth_address
        self.rtmp_secret = rtmp_secret
        self.ip_address = ip_address


===== ./models/__init__.py =====



===== ./models/magnet.py =====

class MagnetURL(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    eth_address = db.Column(db.String(42), nullable=False)
    magnet_url = db.Column(db.Text, nullable=False)
    snapshot_index = db.Column(db.Integer, nullable=False)
    created_at = db.Column(db.DateTime, server_default=db.func.now())



===== ./__init__.py =====



===== ./system/requirements.txt =====
Flask
redis
psycopg2-binary
Flask-SQLAlchemy
flask-cors
requests
Flask-RESTful
web3
docker
cryptography
python-dotenv


===== ./system/Dockerfile =====
# Use the official Python image
FROM debian:bullseye-slim

# Set the working directory inside the container
WORKDIR /app

# Install system dependencies including PostgreSQL and Redis
RUN apt-get update && apt-get install -y \
    postgresql \
    redis-server \
    gcc \
    python3 \
    python3-pip \
    libpq-dev

# Install Python dependencies
COPY ./system_files/requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the application code into the container
COPY . .

# Copy the custom pg_hba.conf file
COPY ./system_files/pg_hba.conf /etc/postgresql/15/main/pg_hba.conf

# Set the appropriate permissions on the PostgreSQL configuration
RUN chown postgres:postgres /etc/postgresql/15/main/pg_hba.conf

# Expose necessary ports
EXPOSE 5003 5432 6379

# Create entrypoint script to start services
COPY ./system_files/entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# Start the entrypoint script
CMD ["/entrypoint.sh"]



===== ./system/entrypoint.sh =====
#!/bin/bash

# Start PostgreSQL service
service postgresql start

# Start Redis server
service redis-server start

# Wait for PostgreSQL to start
until pg_isready -h localhost; do
  >&2 echo "Postgres is unavailable - sleeping"
  sleep 1
done

# Switch to the postgres user and create the 'admin' user and DATABASE_URL database
su - postgres -c "psql -c \"CREATE USER admin WITH PASSWORD 'admin';\""
su - postgres -c "psql -c \"ALTER USER admin WITH SUPERUSER;\""
su - postgres -c "psql -c \"CREATE DATABASE rtmp_db;\""
su - postgres -c "psql -c \"GRANT ALL PRIVILEGES ON DATABASE rtmp_db TO admin;\""

# Create the magnet_urls table in DATABASE_URL
su - postgres -c "psql -d rtmp_db -c \"
CREATE TABLE IF NOT EXISTS magnet_urls (
    id SERIAL PRIMARY KEY,
    eth_address VARCHAR(255) NOT NULL,
    magnet_url TEXT NOT NULL,
    snapshot_index INT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);\""

# Restart PostgreSQL to apply changes
service postgresql restart

# Wait for PostgreSQL to restart and be available again
until pg_isready -h localhost; do
  >&2 echo "Waiting for Postgres to restart - sleeping"
  sleep 1
done

# Start the Flask application
python3 app.py



===== ./system/pg_hba.conf =====
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     md5
# IPv4 local connections:
host    all             all             psichos.is/32            md5
# IPv6 local connections:
host    all             all             ::1/128                 md5
# Allow replication connections from localhost, by a user with the replication privilege.
local   replication     all                                     md5
host    replication     all             psichos.is/32            md5
host    replication     all             ::1/128                 md5



===== ./services/__init__.py =====



===== ./services/magnet.py =====

def _clear_magnet_urls(eth_address):
    try:
        MagnetURL.query.filter_by(eth_address=eth_address).delete()
        db.session.commit()
        return {"message": f"All magnet URLs for {eth_address} have been cleared."}, 200
    except Exception as e:
        db.session.rollback()
        return {"error": f"Failed to clear magnet URLs: {str(e)}"}, 500

def _store_magnet_url(eth_address, magnet_url, snapshot_index):
    new_magnet_url = MagnetURL(eth_address=eth_address, magnet_url=magnet_url, snapshot_index=snapshot_index)
    db.session.add(new_magnet_url)
    db.session.commit()
    return {"message": "Magnet URL stored successfully"}, 200


===== ./services/auth.py =====

HMAC_SECRET_KEY = Config.HMAC_SECRET_KEY

def _generate_secret():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=16))

def _hash_secret(secret):
    return hmac.new(HMAC_SECRET_KEY.encode(), secret.encode(), hashlib.sha256).hexdigest()

def _store_secret(eth_address, secret, ip_address):
    new_user = User(eth_address=eth_address, rtmp_secret=secret, ip_address=ip_address)
    db.session.add(new_user)
    db.session.commit()


def _fetch_secret_from_api(eth_address):
    try:
        response = requests.get(f"http://localhost:5003/get_secret/{eth_address}", timeout=5)
        if response.status_code == 200:
            return response.json().get('secret')
        else:
            logging.warning(f"[fetch_secret_from_api] Failed to get secret for {eth_address}: {response.status_code}")
            return None
    except Exception as e:
        logging.error(f"[fetch_secret_from_api] Exception fetching secret for {eth_address}: {e}")
        return None



===== ./extensions.py =====
# extensions.py
from flask_sqlalchemy import SQLAlchemy
import redis

db = SQLAlchemy()
redis_client = redis.StrictRedis(host='localhost', port=6379, db=0, decode_responses=True)



===== ./app.py =====
# app.py
from flask import Flask
from config import Config
from extensions import db, redis_client
from models import User, MagnetURL
from blueprints.routes import blueprint

app = Flask(__name__)
app.config.from_object(Config)

db.init_app(app)

app.register_blueprint(blueprint)

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(host='0.0.0.0', port=5003, debug=True)



===== ./utils/files.py =====
def load_json_file(path):
    if not os.path.exists(path):
        return []
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except json.JSONDecodeError:
        return []

def save_json_file(path, data):
    with open(path, 'w') as f:
        json.dump(data, f)


def allowed_file(filename):
    return True




===== ./utils/__init__.py =====
from .crypto import generate_ecc_key_pair, serialize_public_key, encrypt_secret
from .files import load_json_file, save_json_file
from .helpers import gen_poster_id, ip_to_int



===== ./utils/helpers.py =====
import random
import ipaddress

def gen_poster_id():
    return '%04X' % random.randint(0, 0xFFFF)

def ip_to_int(ip_str):
    return int.from_bytes(ipaddress.ip_address(ip_str).packed, byteorder="little") << 8



===== ./utils/crypto.py =====

def generate_ecc_key_pair():
    private_key = ec.generate_private_key(ec.SECP256R1())
    public_key = private_key.public_key()
    return private_key, public_key



def serialize_public_key(public_key):
    return public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode('utf-8')


def encrypt_secret(secret, public_key):
    return base64.b64encode(secret.encode()).decode('utf-8')



===== ./config.py =====
# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    SECRET_KEY = os.getenv("SECRET_KEY", "dev")
    LOG_FILE_PATH = os.getenv("LOG_FILE_PATH", "logs/app.log")
    SQLALCHEMY_DATABASE_URI = os.getenv('DATABASE_URI', 'postgresql://admin:admin@localhost/rtmp_db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    HMAC_SECRET_KEY = os.getenv('HMAC_SECRET_KEY', '11257560')
    WEBTORRENT_URL = os.getenv('WEBTORRENT_URL', 'https://webtorrent')
    WEBTORRENT_PORT = int(os.getenv('WEBTORRENT_PORT', 5002))
    REDIS_HOST = os.getenv('REDIS_HOST', 'localhost')
    REDIS_PORT = int(os.getenv('REDIS_PORT', 6379))
    REDIS_DB = int(os.getenv('REDIS_DB', 0))



